import { ChapterObject } from "@/types";

const cpp_ch2: ChapterObject = {
  id: "cpp_ch2",
  content: [
    {type: "header", content: "Getting Started"},
    {
      type: "view",
      title: "Compiler Continued",
      content: [
        {
          type: "text",
          content:"The compiler is the C++ programmer's most important tool; no compiler, no program. This chapter will help you set it up for beginning compilation."
        },
        {
          type: "text",
          content: "If you're using an IDE, make sure default flags are turned off. This is especially true for VIsual Studio since it has a different compiler with different unique features. This can be found in compiler [configuration] options."
        },
        {
          type: "text",
          content: "The best flags for beginners are: -Wall, -Wextra, -Werror, and -std=c++20"
        },
        {
          type: "subheading",
          content: "-Wall"
        },
        {
          type: "text",
          content: "Throws almost all warnings generated by the compiler. Really just enables most warning flags."
        },
        {
          type: "subheading",
          content: "-Wextra"
        },
        {
          type: "text",
          content: "Enables more warning flags that -Wall didnt."
        },
        {
          type: "subheading",
          content: "-Werror"
        },
        {
          type: "text",
          content: "Treats warnings as errors (no executable is produced if a warning is thrown). Helps beginners get accustomed to fixing warnings rather than ignoring them."
        },
        {
          type: "subheading",
          content: "-std=c++20"
        },
        {
          type: "text",
          content: "Enables C++20 features and treats deprecated code as errors (code that worked in the C++17 standard that became deprecated in the C++20 standard will be treated as an error). g++ doesn't require this flag."
        },
        {
          type: "text",
          content: "Other popular flags worth mentioning are -g (generates debugging information for the debugger) and -o (renames the output/executable. Default name is a.out or a.exe). There are many other useful flags you can find in the compiler's user manual."
        },
        {
          type: "error",
          kind: "Warning",
          content: "-Weffc++ and -pedantic are also popular, but can cause bugs and give false positives. While I never had a problem with them, use them with caution! I will not use them for this book."
        }
      ]
    },
    {
      type: "view",
      title: "Compiler Stages",
      content: [
        {
          type: "text",
          content: "The compiler must go through some stages before making your executable: preprocessing, parsing and semantic analysis, code generation and optimization, assembling, and linking. Stages may vary depending on your compiler."
        },
        {
          type: "subheading",
          content: "Preprocessing"
        },
        {
          type: "text",
          content: "This stage tokenizes your source files (breaks up keywords and characters such as white spaces, braces, semi-colons, etc.), expands your macros, includes, and other preprocessor directives."
        },
        {
          type: "text",
          content: "This stage produces a .ii file (.i if the source was C)."
        },
        {
          type: "subheading",
          content: "Parsing and Semantic Analysis"
        },
        {
          type: "text",
          content: "It translates the tokens into a parse tree (known as an Abstract Syntax Tree (AST)). Once the tree is formed, it then applies semantic analysis to determine the types for expressions and determine if the code is well formed."
        },
        {
          type: "text",
          content: "This stage is where warnings and errors are thrown."
        },
        {
          type: "subheading",
          content: "Code Generation and Optimization"
        },
        {
          type: "text",
          content: "This stage translates the AST into low-level intermediate code ([framework] IR which is a platform-independent programming language. You may have seen it as LLVM IR for clang or GIMPLE for GCC), then translates it into machine code."
        },
        {
          type: "text",
          content: "Since this stage deals with assembler code, it is mostly responsible for optimization and handling target-specific code generation."
        },
        {
          type: "text",
          content: "Outputs .s file."
        },
        {
          type: "subheading",
          content: "Assembler"
        },
        {
          type: "text",
          content: "This stage runs the target assembler (the assembler your compiler uses may vary, hence the term \"target\") which translates the compiler's output into an object file."
        },
        {
          type: "text",
          content: "Outputs .o file."
        },
        {
          type: "subheading",
          content: "Linker"
        },
        {
          type: "text",
          content: "This stage runs the target linker which merges all the object files into an executable or dynamic library."
        },
        {
          type: "text",
          content: "Outputs .out, .dylib, or .so file."
        }
      ]
    },
    {
      type: "view",
      title: "Hello World",
      content: [
        {
          type: "text",
          content: "The \"Hello World\" program is a small program used in software development to test if the build environment has been set up properly."
        },
        {
          type: "text",
          content: "Make a file named helloworld.cpp and fill it with the following contents (IDE users, make a new project):"
        },
        {
          type: "code",
          content: `
// Must be # without \'\\\'
\\#include <iostream> // Include the IO library

// Entry point
int main(int argc, char const* argv[]) {
  std::cout << \"Hello World\\n\"; // Output text to STDOUT

  // Added to test for C++20 support
  []<typename T>(std::vector<T> vector){};

  // Return 0 to the caller
  return 0;
}
          `
        },
        {
          type: "text",
          content: "If you're on an IDE, normally you'd hit a RUN button and that will build and run your program (see the IDE's user manual). If you're on the terminal (replace g++ with clang++ if using clang): "
        },
        {
          type: "code",
          content: `g++ -Wall -Wextra -Werror -std=c++20 helloworld.cpp -o helloworld`
        },
        {
          type: "text",
          content: "If successful, run the generated executable by: "
        },
        {
          type: "code",
          content: `./helloworld`
        },
        {
          type: "text",
          content: "You should see the text Hello World in a terminal."
        }
      ]
    }
  ]
};

export default cpp_ch2;